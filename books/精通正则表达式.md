# 精通正则表达式
## 第一章
- 元字符是语法，普通文字是文字
- 按照字符来理解正则表达式 ‘^cat’是以c开头，后面接一个a再接一个t的文本
- ^ $ 匹配的是位置
- [...] 表示字符组 匹配里面的一项， 字符组里的特殊字符比如!?.等都失去了特殊字符的作用 仅仅是普通文字，比如[0-9a-zA-Z_!.?]可以匹配数字，大小写字母，下划线，感叹号，句号，问号。
- [^...]匹配一个未列出...的文字，一个字符组，即使是排除型字符组也需要匹配一个字符。
- 连字符-如果不在字符组的开头则表示匹配连字符-，否则表示范围
- 一个字符组只能匹配目标文本中的单个字符，而每个多选结构自身都可能是完整的正则表达式，都可以匹配任意长度的文本
- 例子
    - 变量名：「[a-zA-Z][a-zA-Z_0-9]*」
    - 引号内的字符串： 「"[^"]*"」
    - 美元金额：「\$[0-9]+(\.[0-9][0-9])?」
    - 匹配时刻比如9:17am：「(1[012] | [1-9]):[0-5][0-9]([a|p]m)」
    - 匹配24小时：「(1[0-9]|2[0-4]|[1-9]):[0-5][0-9]」
    - 匹配正负带小数点数「^[-+]?[0-9]+(\.[0-9]*)?$」
- 子表达式的编号按照开括号的出现先后排序，从1开始。子表达式可以嵌套，例如「(wash(DC)?)」。如果只是希望分组，也可以使用「(...)」，但是副作用是捕获的文本仍然会保存到特殊变量$1等中，如果不需要保存则用(?:x)
- 将123456 改成 123,345这种数字 「(?<=\d)(?=(?:(\d\d\d)+(?!\d)))」这个正则匹配到了需要加逗号的位置
## 正则表达式的匹配原则
- **优先选择最左（最靠开头）的匹配结果**
    - 匹配先从需要查找的字符串的起始位置尝试匹配
    - 尝试匹配是指：在当前位置测试整个正则表达式能匹配的每样文本
    - 如果在当前位置测试了所有的可能之后不能找到匹配结果，就从字符串的第二个字符之前的位置开始重新尝试
    - 只有尝试过所有的起始位置都不能找到匹配结果的情况下，才会报告匹配失败
- **标准的匹配量词（「*」「+」「?」和{m,n}）是匹配优先的**
- 固化分组 (?>...),如果匹配进行到此结构之后，那么此结构体中的所有备用状态都会被放弃。 例子：「(\.\d\d(?>[1-9]?))\d+」，在固化分组中，量词能够正常工作，所以需要「[1-9]」不能匹配，正则表达式会返回「?」留下的备用状态。然后匹配脱离固化分组，继续前进到「\d+」，在这种情况下，当控制权离开固化分组时，没有备用状态需要放弃。如果「1-9」能够匹配，匹配脱离固化分组后，「?」保存的备用状态依旧存在，但是因为它属于已经结束的固化分组，所以会被抛弃。匹配".625"或“.625000”是就会发生这种情况
- 占有优先量词，?+、*+、++ 和 {m,n}+，从来不交还已经匹配的字符
- 用肯定环视来模拟固化分组 「(?>regex)」可以用 「(?=(regex))\1」比如 「(?>\w+):」 等于 「^(?=(\w+))\1:」

## 正则表达式引擎
### 分类
- DFA(电动车)
- NFA(汽油车)
- POSIX NFA (符合某种标准的车)
- DFA引擎要更快一点

### 测试
```js
let str2 = 'nfa not'
const reg = /nfa|nfa not/
str2.match(reg)
// ["nfa", index: 0, input: "nfa not", groups: undefined]
```
根据测试可得，**Javascript的正则表达式是传统的NFA，如果结果是nfa not 则是POSIX NFA 或者 DFA**

- NFA（非确定型有穷自动机）引擎是表达式主导，以正则表达式某一部分为依据来于文本进行对照
- DFA（确定型有穷自动机）引擎是以文本主导，在扫描字符串的时候会记录当前有效的所有可能，它会先遍历文本，其扫描的字符串中的每个字符都对引擎进行了控制



### 零件
正则表达式的零件分为几类-文字字符，量词，字符组，括号等等
### NFA的括号、反向引用和忽略优先量词
1. 括号不会影响正则表达式的匹配过程
2. 表达式中某些部分可能强迫之前匹配优先的部分释放（交还）某些字符

### 回溯
1. NFA引擎最重要的性质是，它会依次处理各个子表达式或组成元素，遇到需要在两个可能成功的可能中进行选择时，它会选择其一，同时记住另一个，以便稍后可能的需要

2. 需要作出选择的情形包括量词和多选结构

3. 面对众多选择时哪个分支应当首先选择
```
    如果需要在“进行尝试”和”跳过尝试“之间进行选择，对于匹配优先量词，引擎会优先选择”进行尝试“，而对于忽略优先量词会选择”跳过尝试“
```

4. 回溯进行时，应该选取哪个保持的状态
```
    距离当前最近储存的选项就是当本地失败强制回溯时放回的，使用的原则时后进先出
```

5. 忽略优先量词： 在量词后面加个? 比如 *?

6. 排除环视 (!?x)

7. 固化分组(?>x)在某个可选元素已经匹配成功的情况下才抛弃此元素的“忽略”状态。主要应用在放弃某些不用的可能性
8. 占有优先量词 ?+、*+、++、{m,n}+ 从来不交还已经匹配的字符，与固化分组对应

#### 环视中的回溯
环视结构中的子表达式有自己的世界，它也会保存备用状态，进行必要的回溯。如果正则表达式发现需要进一步回溯到当前的环视结构的起点以前，它就认为当前子表达式无法匹配。环视结构的匹配尝试结束，它不会留下任何备用状态。

#### 多选结构
NFA的多选结构既不是匹配优先的，也不是忽略优先的，而是按照顺序排列的

### 最左最长规则
DFA会选择可能中最左最长的匹配结果
### 绝对最长
NFA选择多选结构是根据表达式顺序，DFA是根据多选条件的长度，DFA会选择最长的分支

## 正则表达式的使用技巧
### 经验
1. 如果不需要什么，就应该将它换成字符组。比如如果不需要点号匹配反斜线，就应该把点号换成「[^\n\\]」
## 正则表达式应用到目标字符串的过程
1. 正则表达式编译。检查正则表达式的语法正确性，如果正确，就将其编译为内部形式
2. 传动开始。传动装置将正则引擎“定位”到目标字符串的起始位置。
3. 元素检测。 引擎开始测试正则表达式和文本，依次测试正则表达式的各个元素
    - 1. **相连元素**，如「Subject」中的每个字符都会被依次尝试知道失败才停止
    - 2. **量词修饰的元素，控制权在量词**（检测量词是否应该继续匹配）和被限定的元素（测试能否匹配）之间转换
    - 3. **控制权在捕获型括号内外进行切换会带来一些开销，括号内的表达式匹配的文本必须保留**，这样才能通过$1来引用。因为一对括号可能属于某个回溯分支，括号的状态就是用于回溯的状态的一部分，所以进入和退出捕获型括号时需要修改状态。
    - 4. **寻找匹配结果**。如果找到一个匹配结果，传统型NFA会“锁定”在当前状态，报告匹配成功。而对于POSIX NFA来说，如果这个匹配是迄今为止最长的，它会记住这个可能的匹配然后从可用的保存状态继续下去，保存的状态都测试完毕之后返回最长的匹配。
    - 5. **传动装置的驱动过程** 如果没有找到匹配，传动装置就会驱动引擎，从文本的下一个字符开始新一轮的尝试。
    - 6. **匹配彻底失败** 如果从目标字符串的每一个字符开始的尝试都失败了，就会报告匹配彻底失败。



## 提高正则表达式的效率
### 正则表达式引擎的提升
1. 预查必须字符/字符串优化
2. 长度判断优化
3. 字符串起始/行锚点优化。这种优化措施能够判断，任何以「^」开始的正则表达式只有在「^」能够匹配的情况下才可能匹配，所以只需要这些位置即可。所以「^(this|that)」比「^this | ^that」效率更高
4. 字符串结束/行锚点优化。遇到末尾为「$」或者其他结束锚点的正则表达式时，能够从字符串末尾倒数若干字符的位置开始尝试匹配。
5. 开头字符/字符组/子串识别优化。容许传动装置进行快速子字符串检查从而能够在字符串中合适的位置应用正则表达式。比如「this|that|other」只能从「[ot]」的位置开始匹配。能够预先检查的子串越长，“错误的开始位置”就越少
6. 内嵌文字字符串检查优化。它针对的是在匹配固定位置出现的文字字符串。比如正则表达式「\b(perl|java\.regex\/info\b」 那么，任何匹配中都要有'.regex.info'，然后往前数4个字符，开始实际应用正则表达式。这种优化只有在内嵌文字字符串与表达式起始位置的距离固定时才能进行。
7. 长度识别传动优化。如果当前位置距离字符串末尾的长度小于成功匹配所需要最小长度，则停止匹配。

### 优化正则表达式本身
1. 文字字符串连接优化。让引擎把「abc」当作「abc」而不是「a」「b」「c」
2. 化简量词优化。
3. 消除无必要括号
4. 消除不需要的字符组
5. 忽略优先量词之后的字符优化。如果文字字符跟在忽略优先量词之后，只要引擎没有触及那个文字字符，忽略优先量词可以作为普通的匹配优先量词处理
6. 量词等量转化。「\d{4}」比「\d\d\d\d」
效率更高，在NFA中

### 常识性优化
1. 避免重新编译。避免变量插值，重复使用。
2. 使用非捕获型括号。节省捕获时间，减少回溯使用的状态的数量
3. 不滥用括号
4. 不滥用字符组
5. 使用起始锚点
6. 将文字文本独立出来。
7. 从量词中“提取必须“的元素。比如用「xx*」代替「x+」能够暴露匹配必须的'x'
8. 提取多选结构开头或结尾的必须元素。比如用「th(?:is|at)」代替「(?:this|that)」
9. 将锚点独立出来
10. 在表达式前面独立出「^」和 \G。「^(?abc|123)」和「^abc | ^123」在逻辑上等价，但是前者会被使用开头字符/字符串/字符识别优化。
11. 在表达式尾部独立出$
12. 按照具体情况选择忽略或者匹配优先
13. 拆分正则表达式
14. 使用固化分组和占有优先量词。


### 进行修改时参考的评价
1. 哪种引擎从中获益？传统型NFA 或者 POSIX NFA 或是两者
2. 什么情况下，这种修改带来的收益最大？在文本能够匹配时，无法匹配时，还是所有时候

### 经验
1. 如果某个结构经常出现，那就放在前面
2. 字符组和多选结构根据情况互换
3. 加速某些操作。 某些类型的匹配比如「\d+」极为常见，引擎可能对此有特殊的处理方案，执行速度比通用的处理机制要快。
4. 避免冗余操作。如果引擎认为，对于产生正确结果来说，某些特殊的操作是不必要的，或者某些操作能够应用到比之前更少的文本，忽略这些操作能够节约时间。比如 一个以「\A」(行开头)开头的正则表达式只有在字符串的开头位置才能匹配，如果在此处无法匹配，传动装置不会徒劳地尝试其他位置。

### 正则表达式的性能测试
- 记录系统运行时间：先取系统时间，运行程序，再取系统时间，计算两者的差。如果时间低于系统的精度，就多运行几遍。

