# 精通正则表达式
## 第一章
- 元字符是语法，普通文字是文字
- 按照字符来理解正则表达式 ‘^cat’是以c开头，后面接一个a再接一个t的文本
- ^ $ 匹配的是位置
- [...] 表示字符组 匹配里面的一项， 字符组里的特殊字符比如!?.等都失去了特殊字符的作用 仅仅是普通文字，比如[0-9a-zA-Z_!.?]可以匹配数字，大小写字母，下划线，感叹号，句号，问号。
- [^...]匹配一个未列出...的文字，一个字符组，即使是排除型字符组也需要匹配一个字符。
- 连字符-如果不在字符组的开头则表示匹配连字符-，否则表示范围
- 一个字符组只能匹配目标文本中的单个字符，而每个多选结构自身都可能是完整的正则表达式，都可以匹配任意长度的文本
- 例子
    - 变量名：「[a-zA-Z][a-zA-Z_0-9]*」
    - 引号内的字符串： 「"[^"]*"」
    - 美元金额：「\$[0-9]+(\.[0-9][0-9])?」
    - 匹配时刻比如9:17am：「(1[012] | [1-9]):[0-5][0-9]([a|p]m)」
    - 匹配24小时：「(1[0-9]|2[0-4]|[1-9]):[0-5][0-9]」
    - 匹配正负带小数点数「^[-+]?[0-9]+(\.[0-9]*)?$」
- 子表达式的编号按照开括号的出现先后排序，从1开始。子表达式可以嵌套，例如「(wash(DC)?)」。如果只是希望分组，也可以使用「(...)」，但是副作用是捕获的文本仍然会保存到特殊变量$1等中，如果不需要保存则用(?:x)
- 将123456 改成 123,345这种数字 「(?<=\d)(?=(?:(\d\d\d)+(?!\d)))」这个正则匹配到了需要加逗号的位置
## 正则表达式的匹配原则
- 优先选择最左（最靠开头）的匹配结果
- 标准的匹配量词（「*」「+」「?」和{m,n}）是匹配优先的
- 固化分组 (?>...),如果匹配进行到此结构之后，那么此结构体中的所有备用状态都会被放弃。 例子：「(\.\d\d(?>[1-9]?))\d+」，在固化分组中，量词能够正常工作，所以需要「[1-9]」不能匹配，正则表达式会返回「?」留下的备用状态。然后匹配脱离固化分组，继续前进到「\d+」，在这种情况下，当控制权离开固化分组时，没有备用状态需要放弃。如果「1-9」能够匹配，匹配脱离固化分组后，「?」保存的备用状态依旧存在，但是因为它属于已经结束的固化分组，所以会被抛弃。匹配".625"或“.625000”是就会发生这种情况
- 占有优先量词，?+、*+、++ 和 {m,n}+，从来不交还已经匹配的字符
- 用肯定环视来模拟固化分组 「(?>regex)」可以用 「(?=(regex))\1」比如 「(?>\w+):」 等于 「^(?=(\w+))\1:」