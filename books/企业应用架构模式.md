# 企业应用架构模式
## 第一章
- 持久化数据
- 大量数据
- 同时访问数据
- 大量操作数据的用户界面
- 与散布在企业周围的其他企业应用集成
### 性能
- 响应时间：完成一次外部请求的时间
- 响应性：系统响应请求的速度。进度条
- 等待时间：获得系统任何形式响应的最小时间
- 吞吐率：给定时间内能够处理多大的请求量
- 负载：当前有多少用户与系统相连
- 负载敏感度：响应时间随负载变化的程度
- 效率：性能除以资源
- 容量：最大有效负载或吞吐率的指标，一个绝对最大值或性能衰减至低于一个可接受的阙值之前的临界点
- 可伸缩性：向系统增加资源对系统性能的影响。垂直可伸缩指提高单个服务器的性能，水平可伸缩指增加服务器数量

## 第二章
### 1.分层
- 上层使用了下层定义的各种服务，而下层对上层一无所知
- 领域层和数据源层绝对不要依赖于表现层

### 2. 组织领域逻辑

## 第三章 映射到关系型数据库
1. 将处理SQL的类独立出来，并且让这些类以数据库中的表结构为基础，一个数据表对应一个类。这是对数据库的入口
2. 有2种入口的组织方法，一是为查询语句返回的每一行产生一个它的实例，这种行数据入口就像用面向对象的方法来看待数据。还有一个是表数据入口，对数据库中的每个表仅仅需要一个对象来管理，提供查询数据库的方法，返回一个记录集。
3. **数据映射器**还有一个更好的方法，是把领域模型和数据库完全独立，可以让间接层完成领域对象和数据库表之间的映射。
4. **工作单元**， 当要保证对读取的数据库数据是独占状态时，应该使用工作单元。工作单元会跟踪所有从数据库中读取的对象以及所有以任何形式修改过的对象，它同样负责将更新提交到数据库。工作单元会排列好对数据库的操作顺序。
5. **延迟加载**，为了避免在读取一个数据时将相关的大量数据一起读取出来，可以利用延迟加载，其主要思想是拥有被修改对象引用，它指向的是一个占位符。当且仅当想要通过链接访问时，才会真的去读取实际的对象。
6. **查找器**，创建独立的查找器对象，每个查找器类都有很多封装了SQL语句的方法，当执行查询操作的时候，查找器对象返回一个适当的基于行的对象集合。
7. 查找器尽量一次读回多行，最好不要为了得到多行而在同一个表上重复查询。
8. 利用联接避免多次进入数据库，数据库必须优化到一次查询中处理3-4个联接，如果超出性能会受损。


## 第5章 并发
### 一、大纲
#### 1. 什么是并发
并发的本质问题是多人在同一时间段对公共资源产生修改后如何同步的问题，包括更新丢失，读取不一致。读取不一致代表在读取之时是某个值，但是读取之后就被立即修改，导致得到的结果其实和数据库里的结果不一致。
### 2. 并发问题会产生的上下文
描述了在业务软件中并发会发生在请求和会话这两个场景下，在系统中并发会发生在线程和进程中，在数据库中会发生在事务中。

> 并发包括2个场景，请求和会话。请求表示外部环境对软件发起的一次调用，会话表示客户端和服务器之间一次长时间的交互，是1到多个逻辑上有关联请求的集合。

### 3. 解决并发问题的原则
原则包括隔离和不变性。隔离是让每一片数据都只能被一个执行单元访问，内存数据不被共享；不变性是通过定义某些数据是不变的而是的不需要考虑它们被概念从而共享它们。

### 4. 可变数据如何解决并发问题（如何解决更新丢失问题）
乐观锁和悲观锁，也可以说是冲突检测和冲突避免，乐观是让多方修改之后，后面提交的人要解决矛盾后融合，悲观是当有人在修改，就不能再修改，只能只读。



### 5. 如何解决读取不一致的问题

描述了2种方法，1是利用悲观锁策略，2是利用时序读策略。



>悲观锁。读取数据需要一个读锁，写数据需要一个写锁，多个人可以对同一份数据同时拥有读锁，当有其他人有了读锁，其他人就不能在得到写锁；另一种情况是，当有人得到写锁，其他人就不能再得到这两种锁种的任何一种。

>不一致的检测方法是通过读取的数据和共享数据进行版本标记比较，任何不同都以为着冲突的发生。

>时序读。在每次读取数据的时候都使用某种时间戳或其他不变的标签作为约束条件、数据库根据时间或者标签返回数据。

### 6. 死锁的产生与解决方法
描述了死锁的含义即想要得到的锁被其他人占有且无法释放就会产生死锁。以及解决死锁的方法，包括超时控制，检测机制处理，强制开始工作时就获得所有可能的锁。
> 超时控制，一旦达到时间限制，所有的锁失效，工作都被丢失

### 7. 事务
描述了事务的含义和特征即ACID（原子性【都完成或都不完成】、一致性、隔离性、持久性），提出了延迟事务，锁升级等概念，介绍了事务隔离的四种级别由低到高包括读未提交，读已提交，可重复读，可串行化。

### 8. 应用服务器并发
介绍了每会话一进程和每会话一线程这两种方法来处理应用服务器并发。每会话一线程可以创建和进入一个隔离区，在隔离区中创建新的对象来处理请求，来保证这些对象不会被其他线程接触到。

## 第六章 会话状态
### 一、大纲
#### 1. 无状态的好处
如果在请求之间不需要保存状态，就不用关心哪个对象来处理某一次请求；如果状态需要保存，就必须昭通一个对象来处理，无状态使得我们可以缓存这些对象，用很少的对象处理很多的用户。



### 二、摘抄
#### 2. 会话状态
购物车的内容就是会话状态，具有原子性，一致性，隔离性和持久性，也包括了很多无效信息，不能把会话中的所有数据都看成会话状态。

#### 3.存储会话状态的3种方法
介绍了客户会话状态，服务器会话状态，数据库会话状态的含义以及它们的优缺点；还介绍了会话迁移和会话亲和的含义。提出了存储会话状态会出现的问题比如用户消失或取消会话，客户机崩溃，服务器死掉，网络连接断掉，

#### 4. 总结
当数据量小时用客户会话状态，否则用服务器会话状态且配上远程备忘文件，当需要故障恢复和集群的时候或者无法存储远程备忘文件的时候，或者不关心会话间数据隔离的时候可以用数据库会话状态。

> 客户会话状态。用URLCookie，串行化数据使其成为Web表单种的某个隐藏域，把数据放在胖客户端的对象结构里。需要注意数据大小，可以运输少量数据，还要注意数据安全，应该对数据加密。

> 服务器会话状态。把数据存在内存种，也可以放在服务器的文件系统中，以及某种共享的数据源中（数据库表，以会话标示号为关键字，以序列化对象为值）

> 数据库会话状态。把数据分解成多个表和域，保存在数据库中。要注意数据之间的映射，在读取写过程中需要耗时；还必须花力气将会话数据与存放在数据库中的记录数据隔离。

- 在一个零售系统中，每个会话也许没有那么多数据，但肯定有很多处于空闲的用户，因此数据会话状态能发挥很好的性能。在一个租约系统中，则会有不停读写数据库的可能，这时服务器会话状态性能更好。


## 第七章 分布策略
### 一、大纲
#### 1. 远程接口与本地接口的区别
- 本地接口更高效，最好是细粒度的，即对单个属性值操作
- 远程接口十分耗时，性能较低，最好是粗粒度的，即一次性调用可以得到更多属性组成的结果
- 分布对象设计第一定律：不要分布使用对象，而是在每个处理器上都部署所有的对象并在其他节点上复制它们，从而使得每个处理器上的对象只需要本地调用，提高性能，并且用细粒度来设计对象，从而获得更简单的编程模型和更好的维护性。
#### 2. 必须使用的分布的情况
1. 传统客户机与服务器是典型的跨进程划分，因为是不同的计算机，就必定在不同的进程间通信。
2. 应用服务器与数据库也是处于不同进程，但是可以用SQL来提高编程效率。
3. Web服务器与应用服务器处于不同的进程。
4. 因为厂商不同而对软件包进行进程划分。

#### 3. 分布边界
- 系统应该极力减少远程调用，从而使得性能开销最小
- 远程外观是一种粗粒度对象，它实际上不做任何事情，而是提供了一个到细粒度对象的远程接口。相似的对象还有数据传输对象。
- 还有一种分布方法是使用一个代理在进程间迁移对象，利用延迟加载方案的思想来通过网络传递对象。

#### 4. 分布接口
- 基于消息的处理方式（异步）是作者所推崇的。除此之外，如果两个系统是用相同的平台构建，或者二进制编码机制相同则直接使用系统自己的远程调用机制，否则可以使用基于XML的web Service。





